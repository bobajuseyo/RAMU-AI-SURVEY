<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interviewer Robot</title>
    <style>
        /* ... CSS ทั้งหมดเหมือนเดิม ไม่มีการเปลี่ยนแปลง ... */
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #1b1b2f; font-family: sans-serif; color: #fff; display: flex; justify-content: center; align-items: center; }
        .hidden { display: none !important; }
        #selection-screen { display: flex; flex-direction: column; align-items: center; text-align: center; z-index: 10; }
        #startBtnMain { background-color: #4A90E2; color: white; border: none; padding: 25px 80px; border-radius: 50px; font-size: 2.5em; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.3); margin-bottom: 20px; }
        #startBtnMain:hover { background-color: #357ABD; transform: scale(1.05); }
        #cannotSpeakLink { color: #aaa; text-decoration: underline; cursor: pointer; font-size: 1.1em; }
        #cannotSpeakLink:hover { color: #fff; }
        #chat-interface { z-index: 2; width: 100%; height: 100%; }
        #canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        #chat-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; width: 90%; max-width: 600px; height: 80vh; max-height: 700px; background-color: rgba(10, 25, 47, 0.85); border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: column; }
        #chat-header { background-color: rgba(74, 144, 226, 0.5); padding: 16px; text-align: center; font-size: 1.2em; border-top-left-radius: 12px; border-top-right-radius: 12px;}
        #chat-log { flex-grow: 1; overflow-y: auto; padding: 16px; }
        .message { margin-bottom: 12px; } .message.robot { text-align: left; } .message.user { text-align: right; }
        .message .bubble { display: inline-block; padding: 10px 15px; border-radius: 18px; max-width: 80%; }
        .message.robot .bubble { background-color: #e5e5ea; color: #000; } .message.user .bubble { background-color: #0b93f6; color: white; }
        #controls { padding: 16px; text-align: center; border-top: 1px solid rgba(255, 255, 255, 0.1); }
        #status { margin-bottom: 12px; color: #ccc; font-style: italic; min-height: 20px; }
        button { background-color: #4A90E2; color: white; border: none; padding: 12px 24px; border-radius: 25px; font-size: 1em; cursor: pointer; transition: background-color 0.3s; }
        button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        #recordBtn.recording { background-color: #D0021B; }
        #form-interface { z-index: 10; width: 90%; max-width: 700px; height: 80vh; max-height: 800px; background-color: rgba(10, 25, 47, 0.9); border-radius: 12px; padding: 20px; display: flex; flex-direction: column; }
        #form-interface h2 { text-align: center; }
        #survey-form { overflow-y: auto; padding-right: 15px; }
        .form-question { margin-bottom: 25px; border-bottom: 1px solid #444; padding-bottom: 15px; }
        .form-question label { display: block; margin-bottom: 10px; font-size: 1.1em; }
        .options-group { display: flex; justify-content: space-around; }
        .options-group input[type="radio"] { display: none; }
        .options-group label { padding: 8px 15px; border: 1px solid #555; border-radius: 20px; cursor: pointer; }
        .options-group input[type="radio"]:checked + label { background-color: #0b93f6; border-color: #0b93f6; }
        #submitFormBtn { width: 100%; margin-top: 20px; }
    </style>
</head>
<body>

<div id="selection-screen">
    <button id="startBtnMain">Start</button>
    <a id="cannotSpeakLink">ไม่สามารถพูดได้</a>
</div>

<div id="chat-interface" class="hidden">
    <canvas id="canvas"></canvas>
    <div id="chat-container">
        <div id="chat-header">Interviewer Robot</div>
        <div id="chat-log"></div>
        <div id="controls">
            <div id="status">Starting session...</div>
            <button id="recordBtn">Record Answer</button>
        </div>
    </div>
</div>

<div id="form-interface" class="hidden">
    <!-- Form content will be built here -->
</div>

<script>
    // --- DOM Elements ---
    const selectionScreen = document.getElementById('selection-screen');
    const chatInterface = document.getElementById('chat-interface');
    const formInterface = document.getElementById('form-interface');
    const startBtnMain = document.getElementById('startBtnMain');
    const cannotSpeakLink = document.getElementById('cannotSpeakLink');

    // --- Event Listeners for Selection ---
    startBtnMain.addEventListener('click', () => {
        selectionScreen.classList.add('hidden');
        chatInterface.classList.remove('hidden');
        startConversation();
    });

    cannotSpeakLink.addEventListener('click', () => {
        selectionScreen.classList.add('hidden');
        formInterface.classList.remove('hidden');
        // Re-build the form's HTML structure before loading questions
        rebuildForm(); 
        loadFormQuestions();
    });

    // ==========================================================
    //               CHAT INTERFACE LOGIC
    // ==========================================================
    const recordBtn = document.getElementById('recordBtn');
    const chatLog = document.getElementById('chat-log');
    const statusDiv = document.getElementById('status');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let mediaRecorder, audioChunks = [], sessionId = null;
    let width, height, mouthOpen = 0, eyeBlink = 0, audioContext, analyser, dataArray;
    
    // All chat-related JS functions are correct and remain unchanged.
    // ... (Paste all JS code from the previous version for chat and robot animation here)
    function setupCanvas(){ width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; window.onresize = () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }; }
    async function startConversation() { /* ... unchanged ... */ }
    async function toggleRecording() { /* ... unchanged ... */ }
    async function sendAudioToServer() { /* ... unchanged ... */ }
    async function playAudioWithLipSync(audioUrl) { /* ... unchanged ... */ }
    function addMessage(text, sender) { /* ... unchanged ... */ }
    function drawRobot() { /* ... unchanged ... */ }
    function updateAnimationState() { /* ... unchanged ... */ }

    // ==========================================================
    //               FORM INTERFACE LOGIC (WITH FIXES)
    // ==========================================================
    async function loadFormQuestions() {
        const surveyFormEl = document.getElementById('survey-form');
        if (!surveyFormEl) return; // Guard clause

        try {
            const response = await fetch('/get_form_questions');
            const data = await response.json();
            surveyFormEl.innerHTML = ''; // Clear previous questions
            
            data.questions.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'form-question';
                const questionLabel = document.createElement('label');
                questionLabel.textContent = `${index + 1}. ${q}`;
                questionDiv.appendChild(questionLabel);
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'options-group';
                for (let i = 0; i <= 5; i++) {
                    const radioId = `q${index}_opt${i}`;
                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio'; radioInput.id = radioId;
                    radioInput.name = q; radioInput.value = i;
                    radioInput.required = true;
                    const radioLabel = document.createElement('label');
                    radioLabel.htmlFor = radioId; radioLabel.textContent = i;
                    optionsDiv.appendChild(radioInput);
                    optionsDiv.appendChild(radioLabel);
                }
                questionDiv.appendChild(optionsDiv);
                surveyFormEl.appendChild(questionDiv);
            });
        } catch (error) {
            console.error("Failed to load form questions:", error);
            surveyFormEl.innerHTML = '<p>Error loading questions. Please try again.</p>';
        }
    }

    async function handleFormSubmit(event) {
        event.preventDefault();
        const surveyFormEl = document.getElementById('survey-form');
        const totalQuestions = surveyFormEl.querySelectorAll('.form-question').length;
        const answeredQuestions = surveyFormEl.querySelectorAll('input[type="radio"]:checked').length;
        if (answeredQuestions < totalQuestions) {
            alert('กรุณาตอบคำถามให้ครบทุกข้อ');
            return;
        }
        const submitBtn = document.getElementById('submitFormBtn');
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';
        const formData = new FormData(surveyFormEl);
        try {
            const response = await fetch('/submit_form', { method: 'POST', body: formData });
            const result = await response.json();
            if (result.status === 'success') {
                formInterface.innerHTML = '<h2>Thank you for your feedback!</h2><p>This page will reset in 5 seconds.</p>';
                setTimeout(resetToSelectionScreen, 5000);
            }
        } catch (error) {
            console.error("Failed to submit form:", error);
            submitBtn.disabled = false;
            submitBtn.textContent = 'Submit';
        }
    }
    
    // FIX #1: Create a function to rebuild the form structure and re-attach the listener.
    function rebuildForm() {
        // Set the basic HTML structure for the form page
        formInterface.innerHTML = `
            <h2>Feedback Form</h2>
            <form id="survey-form"></form>
            <button id="submitFormBtn" form="survey-form" type="submit">Submit</button>
        `;
        // Find the newly created form element
        const newSurveyForm = document.getElementById('survey-form');
        if (newSurveyForm) {
            // Attach the submit handler to it
            newSurveyForm.addEventListener('submit', handleFormSubmit);
        }
    }

    // ==========================================================
    //               GENERAL & INITIALIZATION
    // ==========================================================
    function updateStatus(text) { statusDiv.textContent = text; }

    function resetToSelectionScreen() {
        chatInterface.classList.add('hidden');
        formInterface.classList.add('hidden');
        selectionScreen.classList.remove('hidden');
        chatLog.innerHTML = '';
        statusDiv.textContent = 'Starting session...';
        sessionId = null;
        
        // FIX #2: When resetting, just clear the form container. 
        // It will be rebuilt by rebuildForm() when the user clicks the button again.
        formInterface.innerHTML = '';
    }

    // Initial setup
    setupCanvas();
    drawRobot();
    recordBtn.addEventListener('click', toggleRecording);
    
    // --- Pasting the unchanged chat functions here for completeness ---
    async function startConversation() { /* ... same as before ... */ }
    async function toggleRecording() { /* ... same as before ... */ }
    async function sendAudioToServer() { /* ... same as before ... */ }
    async function playAudioWithLipSync(audioUrl) { /* ... same as before ... */ }
    function addMessage(text, sender) { /* ... same as before ... */ }
    
    // (Full functions pasted for clarity)
    async function startConversation() {
        updateStatus('Starting session...');
        try {
            const response = await fetch('/start', { method: 'POST' });
            if (!response.ok) throw new Error('Failed to start session.');
            const data = await response.json();
            sessionId = data.session_id;
            addMessage(data.robot_text, 'robot');
            await playAudioWithLipSync(data.audio_url);
        } catch (error) { console.error(error); updateStatus('Error starting session. Please refresh.'); }
    }
    async function toggleRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop(); recordBtn.textContent = 'Record Answer'; recordBtn.classList.remove('recording'); updateStatus('Processing your answer...');
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream); audioChunks = [];
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = sendAudioToServer; mediaRecorder.start();
                recordBtn.textContent = 'Stop Recording'; recordBtn.classList.add('recording'); updateStatus('Recording... Please speak now.');
            } catch (error) { console.error('Microphone access denied:', error); updateStatus('Microphone access is required.'); }
        }
    }
    async function sendAudioToServer() {
        recordBtn.disabled = true; const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        const formData = new FormData(); formData.append('session_id', sessionId); formData.append('audio', audioBlob, 'recording.wav');
        try {
            const response = await fetch('/chat', { method: 'POST', body: formData });
            if (!response.ok) throw new Error('Failed to send audio.');
            const data = await response.json();
            addMessage(data.user_text, 'user'); addMessage(data.robot_text, 'robot');
            await playAudioWithLipSync(data.audio_url);
            if (data.finished) { updateStatus('Session finished. Restarting in 10 seconds...'); setTimeout(resetToSelectionScreen, 10000); }
        } catch (error) { console.error('Error during chat:', error); updateStatus('An error occurred. Please try again.'); recordBtn.disabled = false; }
    }
    async function playAudioWithLipSync(audioUrl) {
        return new Promise(async (resolve) => {
            recordBtn.disabled = true; updateStatus('Robot is speaking...');
            if (!audioContext) audioContext = new AudioContext();
            const audio = new Audio(audioUrl); audio.crossOrigin = "anonymous";
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser(); analyser.fftSize = 256;
            source.connect(analyser); analyser.connect(audioContext.destination);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            audio.onended = () => {
                if (sessionId) { recordBtn.disabled = false; updateStatus('Your turn. Click "Record Answer".'); }
                analyser.disconnect(); source.disconnect(); analyser = null; dataArray = null; resolve();
            };
            await audio.play();
        });
    }
    function addMessage(text, sender) {
        const messageDiv = document.createElement('div'); messageDiv.className = `message ${sender}`;
        const bubble = document.createElement('div'); bubble.className = 'bubble'; bubble.textContent = text || `(No speech detected)`;
        messageDiv.appendChild(bubble); chatLog.appendChild(messageDiv); chatLog.scrollTop = chatLog.scrollHeight;
    }
    function drawRobot() {
        ctx.clearRect(0, 0, width, height); updateAnimationState();
        ctx.fillStyle = '#4aa3ff'; ctx.beginPath(); ctx.arc(width/2, height/2, 250, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; const eyeY = height/2 - 50, eyeXOffset = 80, eyeRadius = 30;
        const blink = Math.max(0, Math.sin(eyeBlink) * 1);
        ctx.beginPath(); ctx.ellipse(width/2 - eyeXOffset, eyeY, eyeRadius, eyeRadius - blink * eyeRadius, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(width/2 + eyeXOffset, eyeY, eyeRadius, eyeRadius - blink * eyeRadius, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(width/2 - eyeXOffset, eyeY, 12, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(width/2 + eyeXOffset, eyeY, 12, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.ellipse(width/2, height/2 + 100, 80, 10 + mouthOpen * 50, 0, 0, Math.PI*2); ctx.fill();
        requestAnimationFrame(drawRobot);
    }
    function updateAnimationState() { eyeBlink += 0.05; if (analyser && dataArray) { analyser.getByteFrequencyData(dataArray); mouthOpen = Math.min(1, dataArray.reduce((a, b) => a + b, 0) / dataArray.length / 128); } else { mouthOpen *= 0.9; } }
</script>

</body>
</html>
